package com.aurionpro.bankapp.service;

import java.util.Date;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.aurionpro.bankapp.dto.EditCustomerProfileDto;
import com.aurionpro.bankapp.entity.CustomerAccount;
import com.aurionpro.bankapp.entity.Transaction;
import com.aurionpro.bankapp.entity.TypeOfTransaction;
import com.aurionpro.bankapp.entity.User;
import com.aurionpro.bankapp.repository.CustomerAccountRepository;
import com.aurionpro.bankapp.repository.UserRepository;
import com.aurionpro.bankapp.repository.TransactionRepository;

@Service
public class CustomerServiceImpl implements CustomerService{
	
    @Autowired
    private UserRepository customerRepository;
	
    @Autowired
    private CustomerAccountRepository customerAccountRepository;

    @Autowired
    private TransactionRepository transactionRepository;

    @Override
    public void deposit(long customerAccountNum, double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive");
        }

        CustomerAccount account = getAccount(customerAccountNum);
        account.setCustomerBalance(account.getCustomerBalance() + amount);
        customerAccountRepository.save(account);

        createTransaction(account, customerAccountNum, customerAccountNum, amount, TypeOfTransaction.CREDIT);
    }

    @Override
    public void withdraw(long customerAccountNum, double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive");
        }

        CustomerAccount account = getAccount(customerAccountNum);
        if (account.getCustomerBalance() - amount < 1000) {
            throw new IllegalArgumentException("Insufficient balance");
        }
        account.setCustomerBalance(account.getCustomerBalance() - amount);
        customerAccountRepository.save(account);

        createTransaction(account, customerAccountNum, customerAccountNum, amount, TypeOfTransaction.DEBIT);
    }


    @Override
    public void transfer(long fromAccountNum, long toAccountNum, double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Transfer amount must be positive");
        }

        CustomerAccount senderAccount = getAccount(fromAccountNum);
        CustomerAccount receiverAccount = getAccount(toAccountNum);

        if (senderAccount.getCustomerBalance() - amount < 1000) { 
            throw new IllegalArgumentException("Insufficient balance");
        }

        senderAccount.setCustomerBalance(senderAccount.getCustomerBalance() - amount);
        customerAccountRepository.save(senderAccount);
        createTransaction(senderAccount, fromAccountNum, toAccountNum, amount, TypeOfTransaction.DEBIT);
        
        receiverAccount.setCustomerBalance(receiverAccount.getCustomerBalance() + amount);
        customerAccountRepository.save(receiverAccount);
        createTransaction(receiverAccount, fromAccountNum, toAccountNum, amount, TypeOfTransaction.CREDIT);
    }
    
    @Override
    public boolean updateCustomerProfile(int customerId, EditCustomerProfileDto request) {
        if (request == null) {
            return false; 
        }

        User existingCustomer = customerRepository.findById(customerId).orElse(null);
        if (existingCustomer == null) {
            return false; 
        }
        if (request.getFirstname() != null && !request.getFirstname().isEmpty()) {
            existingCustomer.setFirstname(request.getFirstname());
        }
        if (request.getLastname() != null && !request.getLastname().isEmpty()) {
            existingCustomer.setLastname(request.getLastname());
        }
        if (request.getEmailId() != null && !request.getEmailId().isEmpty()) {
            existingCustomer.setEmailId(request.getEmailId());
        }
        if (request.getCustomerPassword() != null && !request.getCustomerPassword().isEmpty()) {
            existingCustomer.setPassword(request.getCustomerPassword());
        }

        customerRepository.save(existingCustomer);
        return true;
    }



    private CustomerAccount getAccount(long accountNumber) {
        return customerAccountRepository.findByAccountNumber(accountNumber)
                .orElseThrow(() -> new IllegalArgumentException("Account not found"));
    }

    private void createTransaction(CustomerAccount account, long senderAccount, long receiverAccount, double amount, TypeOfTransaction typeOfTransaction) {
        Transaction transaction = new Transaction();
        transaction.setAccount(account);
        transaction.setSenderAccount(senderAccount);
        transaction.setReceiverAccount(receiverAccount);
        transaction.setAmount(amount);
        transaction.setTypeOfTransaction(typeOfTransaction);
        transaction.setDate(new Date());
        transactionRepository.save(transaction);
    }

}
